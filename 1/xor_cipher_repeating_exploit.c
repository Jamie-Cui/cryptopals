#include<stdio.h>
#include<stdlib.h>
#include<string.h>
#include<math.h>

/* Calculate the hamming distance between two strings m1 and m2 (m1 and m2 have the same length) */
int hamming_distance(int m1, int m2){
	int result = 0;
	int temp = m1^m2; // temp = m1 XOR m2

	/* Calculating the number of '1'(binary) in temp */
	for(int j=0; j<8; j++)
		result += (temp>>j)&1;

	return result;
}

/*
 * Base64 single char decoding
 */
u_int32_t base64_char2int(char value){
	u_int32_t result;
	if(value == '+')
		result = 62;
	else if(value == '/')
		result = 63;
	else if(value >= 65 && value <= 90)
		result = value - 65;
	else if(value >= 97 && value <= 122)
		result = value - 97 + 26;
	else if(value >= 48 && value <=57)
		result = value-48+52;
	else 
		result = 0;// deal with padding '='
	return result;
}

/* 
 * Takes a byte array (base64 encoded not hex) as input 
 * Return a ascii string
 */
unsigned char* base64_decode(u_int8_t* in, u_int32_t in_len){
	int chunk_num = in_len/4;
	int out_len = chunk_num*3;
	u_int8_t* out = (u_int8_t*)malloc(sizeof(u_int8_t)*out_len);
	
	for(int i=0; i<in_len; i++){
		in[i] = base64_char2int(in[i]);
	}
	for(int i=0; i< chunk_num; i++){
		u_int32_t chunk_z = 0;
		u_int8_t* chunk_p = in + i*4;
		for(int j=0; j<4; j++)
			chunk_z += chunk_p[j]<<(3-j)*6;
		for(int j=0; j<3; j++){
			*(out + i*3 + 2-j) = (chunk_z & (255<<j*8)) >> j*8;		
		}	
	}
	return out;
}

/* 
	Get the possible key length of a message m 
	Guessing in range (keyszie_min and keysize_max)
*/
int get_key_len(char* m, int keysize_min, int keysize_max){
	/* float array containsing normalized hamming distance for each possible gueses */
	float result[keysize_max-keysize_min+1];

	/* Inittilaze result array */
	for(int i=0; i<(keysize_max-keysize_min+1); i++)
		result[i] = 0;
	/* For every possible key.. calculate its score*/
	for(int i=keysize_min; i<=keysize_max; i++){
		for(int j=0; j<i; j++)
			result[i-keysize_min] += hamming_distance(m[j], m[i+j]);
		//printf("%d\t%.2f\t%.2f\n", i, result[i-keysize_min], result[i-keysize_min]/(float)i);
		result[i-keysize_min] = result[i-keysize_min]/(float)i;
	}
	
	/* Find the minimum hamming distance */
	float min = result[0];
	int keysize = 0;
	for(int i=0; i<(keysize_max-keysize_min+1); i++)
		if(result[i]<min){
			keysize = i+keysize_min;
			min = result[i];
		}
	
	/* return the most possible keysize, normally you can try with 2-3 most minimum keysize instead of just 1 */	
	return keysize;
}


/* Calculate socres for message m, scores are corresponding to English word frequencies*/
int cal_scores(char* m, int len){
	/*scores for letters (Converted from float to int)*/
	int scores[] = {817, 149, 278, 425, 1270, 222, 201, 609, 696, 15, 77, 402, 240, 670, 750, 192, 9, 598, 632, 905, 275, 97, 236, 15, 197, 7};
	int result[26];
	float final = 0;
	int num = 0;
	
	/* Reset result array */
	for(int i=0; i<26; i++) result[i]=0;

	/* Calculate score for each letter*/
	for(int i=0; i<len; i++){
		if(m[i]>64 && m[i]<91)
			result[m[i]-65]++;
		else if(m[i]>96 && m[i]<123)
			result[m[i]-97]++;
		/* rule out meaningless characters */
		//else if((m[i]>33 && m[i]<48) || (m[i] >57 && m[i]<65))
		//	return 0;
	}
	
	/* Accumulate final score */
	for(int i=0; i<26; i++){
		if(result[i]==0)
			continue;
		final += (scores[i] / result[i]);
		num++;
	}
	return final*num;
}

int* exploit(char* cipher, int len){
	//printf("Begining exploit process...\n");
	int scores[128];
	char messages[128][len/2]; // 128 answers, each one has 60 chars
	int* key = malloc(sizeof(int)*128);

	/* for each cipher in the txt file */
	for(int i=0; i<128; i++){
		char result[len];
		
		/* for each cipher character */
		for(int j=0; j<len; j+=2){
			int temp = cipher[j];
			temp = temp << 4;
			temp += cipher[j+1];
			result[j/2] = (char)temp^i;

		}
			
		scores[i] = cal_scores(result, len/2);
		//printf("%d\n", scores[i]);
		memcpy(messages[i], result, len/2);
		key[i] = i;
	}	
	
	for(int i=0; i<128; i++)
		for(int j=i; j<128; j++)
			if(scores[i] < scores[j]){
				int temp1 = scores[i];
				scores[i] = scores[j];
				scores[j] = temp1;
				char temp2[len/2];
			       	memcpy(temp2, messages[i], len/2);
				memcpy(messages[i], messages[j], len/2);
				memcpy(messages[j], temp2, len/2);
				int temp3 = key[i];
				key[i] = key[j];
				key[j] = temp3;
			}
	for(int i=0; i<3; i++){
		//if(scores[i] < 8000)// not English words
		//	continue;
		printf("%d\t%d\t", scores[i], key[i]);
		for(int j=0; j<34; j++)
			printf("%c", messages[i][j]);
		printf("\n");
	}
	return key;
}



void main(){

	int keysize = 0;
	char buffer[68];
	
	FILE* fp;
	fp = fopen("ciphers2.txt", "r"); // contains 64 lines of ciphertext
	if(fp==NULL)
		exit(-1);

	/* each ciphertext has length of 68 */
	while(fgets(buffer, 68, fp)!=NULL){
		unsigned char* temp = base64_decode(buffer, 68);
		/* Calculating the keysize for each ciphertext */
		if(keysize==0){
			printf("Guessing keysize...");
			keysize = get_key_len(temp, 2, 40);
			printf("Done (Keysize: %d)\n", keysize);
		}
				
		/* cut the ciphertext into keysize blocks
		 * And then sovlev the problem as the single byte xor
		 * */
		int s_len = 51/keysize+((51%keysize)!=0);
		char segment[keysize][s_len];
		
		/* seperate into segements */	
		for(int j=0; j < 51; j++){
			segment[j%keysize][j/keysize] = temp[j];
			printf("%c ", temp[j]);
		}
		int* key[keysize];
		
		/* exploit every segements and find the single char key for each segemnt*/		
		for(int j=0; j<keysize; j++)
			key[j] = exploit(segment[j], s_len);
		
		/* [Incomplete] print the possible key combination */
		for(int k=0; k<3; k++){
			for(int j=0; j< keysize; j++)
				printf("%c", key[j][k]);
			printf("\n");
		}
		/* XOR find the plaintext according to the key */
		int count = 0;
		for(int k=0; k<3; k++)
		for(int j=0; j<51; j++, count++){
			printf("%c", (int)temp[j]^(int)key[k][count%keysize]);
		}
		break;
	}
	
	//char m1[] = "this is a test";
	//char m2[] = "wokka wokka!!!";
	//int result = 0;
	//for(int i=0; i<strlen(m1); i++){
	//	result += hamming_distance(m1[i], m2[i]);
	//	printf("Distance: %d\n", result);
	//}
}
